function critEEG_mse_prepare(SUBJ)% Make jobs for each subject/condition to compute MSE% Scales:% >> bsxfun(@rdivide, 256, 1:40): 256.0000  128.0000   85.3333   64.0000   51.2000   42.6667   36.5714   32.0000   28.4444   25.6000   23.2727   21.3333   19.6923   18.2857   17.0667   16.0000   15.0588   14.2222   13.4737   12.8000    12.1905   11.6364   11.1304   10.6667   10.2400    9.8462    9.4815    9.1429    8.8276    8.5333    8.2581    8.0000    7.7576    7.5294    7.3143    7.1111    6.9189    6.7368    6.5641    6.4000% memreq = 14000; % in MB now! with 8e9 mem_availablememreq = 25000; % in MB now! with 16e9 mem_available% timreq = 2*24*60; % 2 days in minutes% timreq = 1.5*24*60; % 1.5 days in minutestimreq = 1*24*60; % 1 days in minutes% timreq = 0.75*24*60;if nargin == 0	SUBJ  = {	  'Sub1'     ...	  'Sub2'    'Sub3'    ...	  'Sub4'   ...	  'Sub5'    'Sub6'    ...	  'Sub7'       'Sub8'  'Sub9' ...	  'Sub10'   ...	  'Sub11' ...	  'Sub12'    'Sub13'      'Sub14'   ...	  'Sub15'   ...	  'Sub16'	  }; %    }; %endsesdirs = { 'ses1' 'ses2' 'ses3'};if ismac  basepath = '/Users/kloosterman/gridmaster2012/kloosterman/projectdata/critEEG';%   basepath = '/Users/kloosterman/beegfs/projectdata/critEEG';  backend = 'local'; % local parforelse  basepath = '/home/mpib/kloosterman/projectdata/critEEG'; % on the cluster%   basepath = '/home/beegfs/kloosterman/projectdata/critEEG'; % on the cluster  backend = 'torque'; % 'slurm'%     backend = 'slurm';%       backend = 'local';  %     [~,hostname]=unix('hostname')  %     if strfind(hostname, 'gpu')  %         backend = 'parfor';  %     endend% triggers = {'stim', 'resp'};triggers = {'stim'};% triggers = {'resp'};if strcmp(backend, 'slurm')  compile = 'no';else  compile = 'yes';endtest = 0;if test; overwrite = 0; else overwrite = 1; end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PREIN = fullfile(basepath, 'preproc'); % use same preproc data as for power% PREIN = fullfile(basepath, 'mse_preproc'); % use data in mse_preproc: longer trialsPREIN = fullfile(basepath, 'preproc_hpf'); % 0.5 Hz hp filter in preprocessingcfg = [];cfg.timwin        = 0.5; % sliding window sizecfg.m             = 2; % pattern lengthcfg.r             = 0.5; % similarity criterion 0.5cfg.timescales    = 1:42; %1:40; % scale list% cfg.timescales    = 1:5; %for hp filtered data% cfg.fix_trialduration = 'yes';cfg.trialduration = 'vardur'; % fixeddur vardurcfg.SDTtype = 'alltrials'; % onlyhits or alltrialscfg.trlcounts = 'ntrlnotmatched'; % matchedntrl ntrlnotmatchedcfg.splithalf = 'yes'; % odd and even trials separatelycfg.robustdetrend = 'no'; % please don't% cfg.robustdetrendorder = 1;cfg.hpfilter = 0; % 0 (not) or > 0 , tried 60cfg.bpfilter = 0; % 0 or [low high]. Per elife reviews% cfg.bpfilter = [2 6]; % 0 or [low high]. Per elife reviews% cfg.bpfilter = [7 11]; % 0 or [low high]. Per elife reviews% cfg.bpfilter = [12 16]; % 0 or [low high]. Per elife reviews% cfg.bpfilter = [17 21]; % 0 or [low high]. Per elife reviewscfg.bsfilter = 0; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [2 6]; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [7 11]; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [12 16]; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [17 21]; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [0.5 21]; % 0 or [low high]. Per elife reviews% cfg.bsfilter = [0.5 2]; % 0 or [low high]. Per elife reviewscfg.phasetimecourse = 'no'; % try MSE on phase time coursecfg.removeERP     = 'no'; % per condition!cfg.removeERPmethod = 'subtract'; % regress or subtract per condition!cfg.recompute_r = 'perscale_toi_sp';      % per_scale    % per_toi    % pertoi_sp (fixed per scale)    % perscale_toi_sp (run til now)    % perscal e_toicfg.coarsegrainmethod = 'filtskip';  % pointavg filtskipcfg.filtmethod = 'lp'; % low pass filter for pointskip cfg.mem_available = 16e9; % in bytes, 8e9 defaultcfg.allowgpu = true;disp(cfg)outstr = 'oddeven'; % ALWAYS CHECK analysis specific outpath% outstr = 'bs2-6hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'bs7-11hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'bs12-16hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'bs17-21hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'bs05-21hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'Hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'hp21hz'; % ALWAYS CHECK analysis specific outpath% outstr = 'nobpf'; % ALWAYS CHECK analysis specific outpath% outstr = '4hzphase'; % ALWAYS CHECK analysis specific outpath% outstr = '1hzphase'; % ALWAYS CHECK analysis specific outpathPREOUT = fullfile(basepath, 'mse', 'hpf_vartrldur', sprintf('%s_r_%s_delERP%s_%s_%s_%s_hpf%d_%s', cfg.coarsegrainmethod, ...  cfg.recompute_r, cfg.removeERP, cfg.SDTtype, cfg.trialduration, cfg.trlcounts, cfg.hpfilter, outstr));mkdir(PREOUT);cfglist = {}; ntrlpercond = [];for itrg = 1:length(triggers)  cfg.trigger = triggers{itrg};  if strcmp(cfg.trigger, 'stim')%     cfg.toi  = -0.5:0.05:1;    cfg.toi = -0.2:0.05:0.6; %for phase time course edges of sliding win cut off  else        cfg.toi = -0.75:0.05:0.5;  end    for isub = 1:length(SUBJ)    subjdir = fullfile(PREIN, SUBJ{isub});    fprintf('\n\nSubject directory: %s  . . .\n', subjdir)    for ises = 1:3       inpath = fullfile(PREIN, SUBJ{isub}, sesdirs{ises});      sesfile = dir(fullfile(inpath, '*clean_costrap_CSD.mat'));      if isempty(sesfile)        warning('Session not found')        continue      end      if length(sesfile) > 1        error('More than 1 file found!')      end      % load ses data      load(fullfile(sesfile.folder, sesfile.name))      %       if isfield(cfg, 'splithalf') && strcmp(cfg.splithalf, 'yes')%         runnopresent = 1:2; % run per ses, lib and cond%       else        runnopresent = unique(data.trialinfo(:,8)); % runno in kol 8%       end      if any(isnan(runnopresent))        warning('nan found, filling in')                runcol = data.trialinfo(:,8);        ntrials = length(runcol);        runorder = [1 3 5 2 4 6; 7 9 11 8 10 12; 13 15 17 14 16 18]; % ses 1 2 3                ntrl1 = ceil(length(find(data.trialinfo(:,1) == 1)) / 3);        ntrl2 = ceil(length(find(data.trialinfo(:,1) == 2)) / 3);                keerpunten = cumsum([ntrl1 ntrl1 ntrl1 ntrl2 ntrl2])';        keerpunten = [[0; keerpunten] [keerpunten; ntrials]];        keerpunten(:,1) = keerpunten(:,1) + 1;                for irun = 1:6          runcol(keerpunten(irun,1):keerpunten(irun,2)) = runorder(ises, irun);        end        data.trialinfo(:,8) = runcol;        save(fullfile(sesfile.folder, sesfile.name), 'data'); % save with filled in trialinfo        runnopresent = unique(data.trialinfo(:,8)); % runno in kol 8      end      %       ntrlpercond(isub,ises,1) = length(find(data.trialinfo(:,1)==1));%       ntrlpercond(isub,ises,2) = length(find(data.trialinfo(:,1)==2));            for run = runnopresent'                  cfg.run = run;        frstind = find(data.trialinfo(:,8) == run, 1, 'first');        cfg.icond = data.trialinfo(frstind,1);                cfg.fileload = fullfile(sesfile.folder, sesfile.name);                cfg.outprefix = fullfile(PREOUT, [SUBJ{isub} '_' sesdirs{ises}]);                cfg.outputfile = sprintf('%s_mse_icond%d_run%d_%s.mat', cfg.outprefix, cfg.icond, cfg.run, cfg.trigger);                if ~overwrite && exist(cfg.outputfile, 'file')          fprintf('%s exists!\n', cfg.outputfile)        else          fprintf('Adding %s . . . \n', cfg.outputfile)          cfglist{end+1} = cfg;        end              end    end  endendif test  cfglist = cfglist(1);else  length(cfglist)endfunhandle = str2func('critEEG_entropy'); %switch backend  case 'local'    tic    cellfun(funhandle, cfglist);    toc  case 'peer'    peercellfun(funhandle, cfglist);  case {'torque' 'qsublocal' 'slurm'}        setenv('TORQUEHOME', 'yes')    mkdir('~/qsub'); cd('~/qsub');    %             if test    %                 options =  '-l nodes=1:ppn=3 -q testing';    %             else        %             end    if strcmp(backend, 'slurm')      options = '-D. -c2 --gres=gpu:1';    else      options =  '-l nodes=1:ppn=2'; % torque %-q testing or gpu    end    switch compile      case 'no'        qsubcellfun(funhandle, cfglist, 'memreq', memreq, 'timreq', timreq*60, ...          'stack', 1, 'StopOnError', false, 'backend', backend, 'options', options, ...          'UniformOutput', false );      case 'yes'%         compiledfun = qsubcompile(funhandle, 'toolbox', {'signal', 'stats'});                compiledfun = qsubcompile(funhandle, 'toolbox', {'signal', 'stats'} ...          , 'executable', ...          'run_kloosterman_master_p41109_b7.sh'); % compiled ft_entropyanalysis function                qsubcellfun(compiledfun, cfglist, 'memreq', memreq, 'timreq', timreq*60, ...          'stack', 1, 'StopOnError', false, 'backend', backend, 'options', options, ...          'UniformOutput', false );    end  case 'parfor'    p = gcp('nocreate');    if isempty(p)      gpuDevice([]);      if gpuDeviceCount        nGPUs = gpuDeviceCount();        parpool('local', nGPUs);      end    end    parfor ibatch = 1:length(cfglist(:))      funhandle(cfglist{ibatch})    end  otherwise    error('Unknown backend, aborting . . .\n')end